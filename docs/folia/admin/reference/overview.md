---
slug: /reference/overview
title: 概述
description: Folia 如何工作的概述。
---

# 项目概述

本文档描述了 Folia 所做更改的抽象概述。Folia 将所有已加载世界中的区块分割成独立 ticking 的区域，以便这些区域可以独立且并行地进行 ticking。首先将描述区域内操作，然后是区域间操作。

## 独立区域的规则

为了确保区域是独立的，维护区域的规则必须确保一个 ticking 区域没有直接相邻的也在 ticking 的邻居区域。以下规则保证了不变性得到维持：
1. 任何 ticking 区域在 ticking 时都不得增长。
2. 任何 ticking 区域最初必须拥有其周界外的一小块区块缓冲区。
3. 如果有相邻的区域，则区域不得**开始** ticking。
4. 相邻区域最终必须合并以形成单个区域。

此外，为了确保一个区域不是由独立的区域组成（这将阻碍并行性），由多个独立区域组成的区域必须在可能的情况下最终拆分为独立的区域。

最后，为了确保 ticking 区域可以存储和维护有关当前区域的数据（即 tick 计数、区域内的实体、区域内的区块、区块/流体 tick 列表等），区域拥有自己的数据对象，该对象只能在 ticking 区域时由 ticking 区域的线程访问。此外，还有合并或拆分区域的回调，以便可以适当地更新数据对象。

这些规则的实现将在 [区域逻辑](region-logic.md) 中描述。

应用这些规则的最终结果是，一个 ticking 区域可以确保只有当前线程具有对区域内包含的任何数据的写入权限，并且在任何给定时间，独立区域的数量都接近最大值。

## 区域内操作

区域内操作是指仅处理单个区域的数据的操作，由拥有区域执行，或指合并/拆分逻辑。

### 独立区域的 Ticking

独立区域独立且并行地进行 ticking。独立 ticking 意味着区域维护自己的调度下一次 tick 的截止时间。例如，考虑两个区域 A 和 B，其中 A 的下一次 tick 开始时间为 t=15ms，B 的下一次 tick 开始时间为 t=0ms。考虑以下事件序列：
1. 在 t = 0ms 时，B 开始 ticking。
2. 在 t = 15ms 时，A 开始 ticking。
3. 在 t = 20ms 时，B 完成了其 tick。然后计划在 t = 50ms 时再次 ticking。
4. 在 t = 50ms 时，B 开始其第二次 tick。
5. 在 t = 70ms 时，B 完成了其第二次 tick，并计划在 t = 100ms 时再次 ticking。
6. 在 t = 95ms 时，A 完成了其**第一次** tick。计划在 t = 95ms 时再次 ticking。

重要的是要注意，B 的计划在任何时候都没有受到 A 落后于其 20TPS 目标的影响。

为了实现所描述的行为，每个区域在计划执行器（参见 `SchedulerThreadPool`）上维护一个重复任务，该执行器根据最早开始时间优先调度算法调度任务。该算法类似于 EDF，但根据开始时间进行调度。但是，考虑到每次 tick 的截止时间为 50ms + 开始时间，它的行为与 EDF 算法完全相同。

选择类 EDF 算法是为了确保只要线程池未被最大程度地利用，所有 ticking 时间 <= 50ms 的区域都将保持 20TPS。但是，调度算法既不感知 NUMA，也不感知 CPU 核心 - 当 n 个区域 > m 个线程时，它不会尝试将区域绑定到某些核心。

由于区域独立 ticking，它们维护自己的 tick 计数器。这的含义将在下一节中描述。

### Tick 计数器

在标准 Vanilla 中，有几个重要的 tick 计数器：当前 Tick、游戏时间 Tick 和日光时间 Tick。当前 Tick 计数器用于确定自服务器启动以来的 tick 数。游戏时间 Tick 按世界维护，用于调度红石、流体和其他物理事件的区块 tick。日光时间 Tick 只是自中午以来的 tick 数，按世界维护。

在 Folia 中，当前 Tick 按区域维护。游戏时间 Tick 分为两个计数器：红石时间和全局游戏时间。红石时间按区域维护。全局游戏时间和日光时间由"全局区域"维护。

在每次区域 tick 开始时，全局游戏时间 tick 和日光时间 tick 从全局区域复制，并且当前区域在任何时候检索这些值时，它将从 tick 开始时收到的副本中检索。这是为了确保在整个 tick 过程中对 tick 数的任何两次检索调用都报告相同的 tick 数。

维护全局游戏时间有几个原因：
1. 需要有一个计数器来表示世界已经存在了多少 tick，因为游戏确实会跟踪世界已经进行了多少天。
2. 大量新的实体 AI 代码使用游戏时间（原因我无法理解）来存储任务的绝对截止时间。编写代码来调整所有这些任务的截止时间并非不可能，但工作量很大。

#### 全局区域

全局区域是一个始终计划以 20TPS 运行的单个计划任务，负责维护不与任何特定区域绑定的数据：游戏规则、全局游戏时间、日光时间、控制台命令处理、世界边界、天气等。与其他区域不同，全局区域不需要执行任何特殊的合并或拆分逻辑，因为它永远不会被拆分或合并 - 在任何时候都只有一个全局区域。全局区域不拥有任何特定于区域的数据。

#### 合并和拆分区域 tick 时间

由于红石和当前 tick 按区域维护，因此需要适当的逻辑来调整区块/流体 tick 调度程序以及任何其他按红石/当前绝对 tick 时间调度的程序使用的 tick 截止时间，以便相对截止时间不受影响。

当将区域 x（源）合并到区域 y（目标或到）时，我们可以调整 x 和 y 的截止时间，也可以只调整 x 和 y 中的一个。只调整一个更容易，并且任意选择区域 x。然后，必须调整 x 的截止时间，以便考虑到 y 的当前 tick，相对截止时间保持不变。

考虑截止时间 d1 = 源 tick + 区域 x 中的相对截止时间。然后我们希望调整后的截止时间 d2 为 d2 = 目标 tick + 区域 y 中的相对截止时间，以便保持相对 tick 截止时间。我们可以通过对 d1 应用偏移量 o 来实现此目的，以便 d1 + o = d2，并且使用的偏移量为 o = 目标 tick - 源 tick。必须分别计算红石 tick 和当前 tick 的此偏移量，因为增加红石 tick 的逻辑可以通过 `Level#tickTime` 字段关闭。

最后，拆分情况很简单 - 当发生拆分时，来自拆分的独立区域从父区域继承红石/当前 tick。因此，相对截止时间得以保持，因为 tick 数没有变化。

在所有情况下，当区域拆分或合并时，红石或任何其他按当前 tick 调度的事件都不会受到影响，因为相对截止时间通过在合并情况下应用偏移量并在拆分情况下复制 tick 数来保持。

## 区域间操作

区域间操作是指与不是当前 ticking 区域的其他区域进行操作，这些区域处于完全未知的状态。这些区域可能是瞬态的、可能是 ticking 的，甚至可能不存在。

### 辅助操作的实用程序

为了辅助区域间操作，提供了几个实用程序。在 NMS 中，这些实用程序是 `EntityScheduler`、`RegionizedTaskQueue`、全局区域任务队列和区域本地数据提供程序 `RegionizedData`。Folia API 具有类似的类似物，但没有区域本地数据提供程序，因为 NMS 数据提供程序持有关键锁，并且在执行任何回调逻辑时在代码的关键区域中调用，因此极易受到涉及长时间 I/O 或世界状态修改的致命插件错误的影响。

#### `EntityScheduler`

`EntityScheduler` 允许将任务计划为在拥有实体的区域上执行。这在处理实体传送时特别有用，因为一旦实体开始异步传送，实体就无法 ticking，直到传送完成，并且时间未定义。

#### `RegionizedTaskQueue`

`RegionizedTaskQueue` 允许将任务计划为在拥有特定位置的区域的下一次 tick 时执行，或者在区域不存在时创建该区域。这对于可能需要编辑或检索当前区域之外的世界/区块/chunk 数据的任务很有用。

#### 全局区域任务队列

全局区域任务队列仅用于对全局区域拥有的数据执行编辑，例如游戏规则、白天时间、天气或使用控制台命令发送器执行命令。

#### `RegionizedData`

`RegionizedData` 类允许区域定义区域本地数据，这允许区域存储数据，而无需考虑来自其他区域的并发数据访问。例如，当前每个区域的实体/区块/区块/流体 tick 列表都得到维护，以便区域无需考虑对这些数据集的并发访问。

这些实用程序允许以简单的方式解决各种跨区域问题，例如通过使用任务队列从任何区域编辑区块/实体/世界状态，或通过使用 RegionizedData 避免并发问题。更高级的操作（例如传送、玩家重生和传送门）都利用这些实用程序来确保操作是线程安全的。

### 实体区域内和跨维度传送

实体需要特殊的逻辑才能在其他区域或其他维度之间安全传送。但是，在所有情况下，对传送/放置实体的调用都必须在拥有实体的区域上调用。`EntityScheduler` 可用于轻松地计划代码以在此类上下文中执行。

#### 简单传送

在简单传送中，实体已经存在于世界中的某个位置，并且目标位置和维度是已知的。此操作分为两个部分：转换和异步放置。在这种情况下，转换操作从当前世界中移除实体，然后调整位置。异步放置操作使用 `RegionizedTaskQueue` 将任务计划到目标位置，以将实体添加到目标维度中的目标位置。

诸如非玩家实体在转换操作中被复制之类的各种实现细节被省略，因为这些细节与高级概述无关。

诸如玩家登录和玩家重生之类的事件通常被认为是简单传送。玩家登录情况仅在玩家在开始时不存在于任何世界中时才有所不同，并且异步转换必须另外找到一个放置玩家的位置。玩家重生类似于玩家登录，因为重生的不同之处在于玩家在重生时位于世界中。

#### 传送门传送

传送门传送与简单传送的不同之处在于，传送门传送**不**知道传送的确切位置。因此，转换步骤不会更新实体位置，而是在转换和异步放置之间插入一个新操作：异步搜索/创建，它负责查找和/或创建出口传送门。

此外，如果实体是非玩家且下界出口传送门尚不存在，则当前 Vanilla 代码可能会拒绝传送。但是由于传送门位置仅由异步放置确定，因此中止为时已晚 - 因此，传送门逻辑已重新完成，以便玩家和实体之间没有区别。现在，实体和玩家都会创建出口传送门，无论是下界还是末地。

#### 传送期间关闭服务器

由于传送发生在多个步骤中，因此服务器关闭过程必须手动处理未完成的传送。

## 服务器关闭过程

关闭过程通过生成一个单独的关闭线程来发生，然后该线程运行关闭逻辑：
1. 关闭 tick 区域调度程序，停止任何进一步的 tick
2. 停止指标处理
3. 禁用插件
4. 停止接受新连接
5. 向所有玩家发送断开连接（但不移除）数据包
6. 停止所有世界的 chunk 系统
7. 通过完成所有区域的所有待处理传送来执行所有世界的关闭逻辑，然后保存世界中的所有区块，最后保存世界的级别数据（level.dat 和其他 .dat 文件）。
8. 保存所有玩家
9. 关闭资源管理器
10. 释放级别锁
11. 停止剩余的执行器（Util 执行器、区域 I/O 线程等）

与 Vanilla 的重要区别在于，玩家踢出和世界保存逻辑被步骤 5-8 取代。

对于步骤 5，玩家不能在传送完成之前被踢出，因为踢出会保存玩家数据文件。因此，保存被移到之后。

对于步骤 6，chunk 系统停止在保存之前完成，以便停止所有区块生成。这将减少服务器关闭时的负载，这在内存受限的情况下可能至关重要。

对于步骤 7，传送完成的方式因类型而异：简单或传送门。

简单传送通过确保将传送实体添加到传送指定的目标区块来完成。这允许实体保存在目标位置，就好像传送在关闭之前已完成一样。

传送门传送通过强制将传送实体添加到源区块来完成，实体应该从该源区块**传送出去**。由于目标位置未知，因此实体只能放回原点（无传送）。虽然此行为并不理想，但关闭逻辑**必须**考虑任何损坏的世界状态 - 这意味着查找或创建目标出口传送门可能不是一个选项。

传送完成必须在世界保存之前执行，以便传送完成的实体保存。

对于步骤 8，仅在传送完成后保存玩家。

其余步骤与 Vanilla 相同。
